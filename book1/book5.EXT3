5_函数：

1.函数的声明：
  func name(parame-list) (result-list) {...body...}
  每个函数声明包含一个名字（name）、一个形参列表（parame-list）、一个可选的返回列表(result-list）以及函数体（body） 
  形参列表指定了一组变量的参数名和参数类型，程序中调用函数会写入实参，函数中所有形参被代入指定的实参进行运算。
  返回值列表是列举要返回变量类型的地方。返回值可以有多个，和c不同。然后当返回值只有一个的时候，可以不写圆括号。同时返回值列表也可以省略，省略即位空，说明函数没有任何返回值，那么这个函数是一个操作函数，它有一段处理，我们需要的就是这么一段处理。如果返回值列表存在，那么函数中一定要有return语句。而且一定要在函数最后。函数前面可以return。但是最后还是要有return。即使不是想在这里返回，那么就返回类型的零值。

2.函数声明的简化：
  当两个列表里面的参数有多个相同时，可以只写一个声明：
  func add(a,b,c,d int) int {...}
和func add(a int,b int,c int,d int) int {...}是一样的。

3.函数的类型：
  函数的类型称作函数签名，当两个函数的形参列表和返回值列表时一样的，那么这两个函数类型相同或者签名相同。两个表里面参数的名字不同不会影响函数相同。（类型相同就可以）

4.函数参数传递：
  函数中实参传递给形参是按值传递，形成函数内部的局部变量。修改局部变量不会对实参造成任何影响。这个是和c一样的。除非实参传递了引用类型，例如函数、指针、map、slice、通道。

5.函数递归：
  函数调用自身的行为通常叫做递归。递归是一种编程技巧。通常在解析html文件时要用到多层递归。递归可以实现阶乘，可以用来实现汉诺塔等需要重复进行的操作。

6.函数闭包/匿名函数:
  func声明后没有函数名的函数就是匿名函数，匿名函数有两种使用方法：
  方法一：在定义匿名函数时直接调用：
  res1 := func(n1 int,n2 int) int {
			return n1 + n2
  }(10,20)
  这里func后面直接跟着的就是参数列表。省略了函数名，所以叫匿名函数。而最后一行的小括号表示输入进这个函数的实参。
  方法二：
  a := func(n1 int,n2 int) int {
		return n1-n2
  }
  res2 := a(20,19)//这里其实是变量赋值而已
  fmt.Println(res2)
  当然也可以直接输出a,但是会输出函数的地址（函数变量是引用类型）想调用函数后面的圆括号是参数列表，不能省略。a(x,y)这里的x和y放入实参。函数(不止是匿名函数有）也有值，可以存进变量里面，这里res2就存放了传入实参后的函数值。

7.函数闭包：
  闭包是由函数及其相关的引用环境组合而成的实体，即：闭包 = 函数 + 引用环境
###引用环境的定义：
  在函数式语言中，当内嵌函数体内引用到体外的变量时，将会把定义时涉及到的引用环境和函数体打包成一个整体（闭包）返回。所以引用环境的意思就是：程序执行中某一点所有处于活跃状态的约束（一个变量名字和其所代表的对象之间的联系）所组成的集合。闭包的使用和正常的函数调用没有区别。
  只有嵌套函数才会出现闭包，那其实很容易理解，先看一下嵌套函数的实现：
  func add(n int) func() {
		n++
		return func() {
			fmt.Println(n)
		}
  }
  函数的嵌套时通过return来完成的。那么最外层函数的返回值列表就要是一个函数类型（要带上返回值列表的括号）(func()这里的参数列表也要写上类型，如果有形参的话)。然后return里面是匿名函数的定义同时调用。这里返回值列表和参数列表都为空。而在里层函数的变量生命周期会变长，变成整个函数的生命周期。

8.嵌套函数的参数的传递：
  以上面例子为例。我们有两种方式来传入参数
  方法一：（调用函数直接用最外层函数名）
  add(n)()
  直接这样写就可以了，有多少个嵌套函数在后面写上多少个"()"。这个圆括号叫做参数列表，就在后面写一排参数列表就可以了。
  方法二：
  A:=add(n)
  A()
  这是先用一个函数类型变量A来接收这个函数，然后再调用函数变量。这里的参数列表()是用来访问下一层函数的。函数名，函数类型其实是索引类型，其实就是指针。函数名指向这个函数的地址。而add就是指向最外层函数的地址，用()访问后，A就是指向第一层的内嵌函数，在这里是最后一层。
  不管有多少曾函数，以上方法都有效。其中第二种如果有三个内嵌函数，还可以写成A()()来传入参数。或者再搞一个函数类型变量。

9.变长函数：
  变长函数调用时可以传递任意参数个数，最熟悉的变长函数时println。
  变长函数的声明：
  func sum(vals ...int) int {
		total := 0
		for _,val := range vals {
			total += val
		}
		return total
  }

  其中的int前面加了三个'.'就表示变长函数。这个类型声明的vals,在【函数体中】就等价于
slice类型。这样调用这个函数时可以传递任意长度的该类型的参数。（甚至可以是0，就是参数列表里面什么都没有）而在函数体中，vals变量不再作为单个元素，而是一个slice，要处理的时候用for range循环单个处理即可。
  虽然vals在函数体中当作slice来用，但是和参数列表里面是slice的函数是不一样的：
  func add1(n ...int) int {...}					func add2(n []int) int {...}
  完全不一样。
###变长函数常用来格式化字符串。

10.延迟函数：（defer关键字）
  调用函数前面加上一个defer关键字可以延迟函数调用，这个函数的调用会推迟到整个函数结束的末尾。
  func main() {
		x,y := 1,2
		defer func(a int) {
			fmt.Println(a,y)
		}(x)
		x+=100
		y+=100
		fmt.Println(x,y)
  }
  这里defer调用函数的和时候，x的值已经传进了defer引用的函数里面，但是函数并没有马上执行，而是等到main函数结尾，也就是fmt.Println(x,y)结束了之后，才执行这个函数。而此时这个函数已经传递了值，x后来的改变，不会影响这个函数原来传递的值，所以最后输出的结果是：
  101 102
  1 102（y的值并没有被传递）函数从外界通过参数列表获取的变量和自身构成了一个闭包。
###defer还可以用来关闭文件。
