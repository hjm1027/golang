###程序结构：大程序都从小的基本组件构建而来：变量存储值（数据），简单表达式通过加和减等操作合并成大的，基本类型通过数组和结构体进行聚合，表达式通过if和for等控制语句来决定执行顺序，语句被组织成函数用于隔离和复用，函数被组织成源文件和包。
2_1名称
1.命名规则：
  函数、变量、常量、类型、语句标签和包都的名称开头时一个字母（unicode中的字符即可）或下划线。后面可以跟任意数量的字符、数字和下划线。并且区分大小写！！！heap和Heap是两个完全不一样的名称。另外所有变量名称不能用go的关键字。go有以下25个关键字：
  break default func interface select case defer go map struct chan else goto
  package switch const fallthrough if range type continue for import return var

  还有三十几个内置的预声明的常量、类型和函数：
  常量：true false iota nil
  类型：int int8 int16 int32 int64 uintptr float32 float64 complex128 complex64
        bool byte rune string error
  函数：make len cap new append copy close delete complex real imag panic recover

  这些名称不是预留的可以在声明中使用它们。但最好不要
###变量名规范：
  一般声明都越简短越好。比较重要的，作用域更大的（甚至有文件作用域）声明才用有意义的，并且长的字母来声明。比如用来计算次数的变量可以用count。几个单词连在一起在c里面会用_相连。但是go里面不会。例如count_array 会写成 countArray 这种叫做驼峰式风格。而且函数名每个单词首写一般会大写。如EscapeHtml 但不会是EscapeHTML
###包里面函数或类型的引用一定要大写：fmt.Printf()

2.变量作用域：
  声明位置决定变量有效（可见）位置。声明在函数内部（包括main）只对函数内局部有效（除非你用make申请内存）声明在函数外的对包里的【所有】源文件有效。这里首字母是否大小写决定了它的可见性是否跨包(是否有文件作用域，别的文件可以访问俄)。如果是大写则是导出的，可被包外的其他程序所引用。如变量Count是导出的，count就不是。

2_2.声明
1.声明的定义：
  声明给一个程序实体（就像变量，类型，常量这种，用来存储）命名，并且设定其部分或全部属性。有4个主要的声明：变量（var）、常量（const）、类型（type）、函数（func）。
  函数的声明：
	func main() {} 最简单的main函数，是程序的入口。func后面的main是函数名。然后（）里面是参数列表。是用来接收外部数据的，可以没有。如果参数列表为空就是不接受数据。（）和{}之间的是返回值列表。也是可选的。不写就是没有返回值。写的话写明返回值的类型（可以有多个，多个时用（）括起来：func a() (int,int){}）

2_3.变量
1.var声明:
  var声明创建一个具体类型的变量，附加名字，设置初始值。每一个声明有一个通用的形式。
  var name type = expression
  type(类型)和表达式(expression)可以省略一个。但不能都省略。如果类型省略，它的类型将由初始化表达式决定（推导类型）。如果初始化表达式省略，那么变量会被初始化为零值。不同类型有不同零值：
  int->0	bool->false !	string->""
  接口和引用类型：
  slice		map		通道	函数
  初始值是nil
  对于数组和结构体这样的复合类型，零值是所有元素或成员的零值。
  
  可以声明一个变量列表进行多个变量同时声明：
  var a,b,c,d int
  var a,b,c,d = ture(bool),2.3(float),2(int),"hello"(string)

  变量也可以通过函数返回值初始化;
  var v,ok = range (map)
  var f,err = open(name)

2.短变量声明：
  name := expression,name的类型由expression决定。短小灵活，在局部变量的声明和初始化中主要使用短变量声明。var一般用于后面赋值。短变量声明也可以同时为多个变量声明。并且类型也可以不一样：
  a,b := 1,true
  多变量声明和多重赋值不一样：
  i,j = j,i 这个是多重赋值，i和j交换数值。
  
  短变量声明有多个时，必须有一个新变量才能运行，对其他旧变量的操作相当于重新赋值。如果都是旧变量，可以直接用"="。

3.指针：
  和c一样，通过指针传递到函数里面的操作才可以传回来，否则只是单向传递。但是go可以直接返回指针。用make分配内存之后也可以保留操作。但是会初始化数组，使元素归零值。

4.new函数声明变量：
  p = new(int) 小括号里面是类型。new返回一个该类型的指针，然后*p=就可以赋值了。new和直接取址局部变量没有什么差别，只是少用了变量名，更加简洁。每一次使用new都会返回一个具有唯一地址的不同变量，但当struct{}或者[0]int时，它们有相同的地址。这是唯一例外。结构体语法复杂，一般不用new。另外new可以重声明，但在这个作用域内就无法用new函数了。

5.多重赋值：
  用多重赋值可以实现变量数值交换： x,y=y,x
  一般会用在简短的赋值时代码更加简洁。如果比较长还是用正常的赋值使代码更易读。
  很多函数会额外多返回一个bool值来说明操作是否成功。还有三个操作符也有类似的行为：
  v,ok = m[key]//map查询
  v,ok = x.(T)//类型判断
  v,ik = <-ch//通道接收
  不需要的返回值就赋值给空标识符。

6.类型:
  在go中的type类型是自己定义了类型，可以是结构体，可以是单个变量类型。主要用于区分类型，避免混淆运算。不同类型中，即使变量的数据类型相同，但是也不能比较和运算。
  type a int
  type b int
  a和b声明为不同类型，就算都为int，也不能运算。

7.作用域：
  {}之间的叫做语法块。这里面的变量声明对外面是不可见的。就是里面声明的变量不会出去。但外面的变量可以在里面访问。这种有大括号的叫做显示语法块。还有一种隐式语法块是那for的语句循环判断语句和if的判断语句那块省略了()的片段。

