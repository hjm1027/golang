复合数据类型
1.数组：（一般很少用）
  声明时要规定数组长度，而且一定要是常数而不能是变量。（在编译的时候是具体的值，不能运行的时候输出进去）。而且不同长度的数组整体不能比较，但是单个数在元素可以比较。

2.数组的声明：
  var a [3]int 中括号里面一定要有东西，而且是编译时有具体数值。如果没有就是切片。
  初始化：
  var a [3]int=[3]int{1,2,3}
  也可以：
  a := [3]int{1,2,3}
  当然短变量声明时，赋值符号后面的那个中括号可以用三个.代表省略号代替，然后元素个数由后面赋值个数确定。注意这种形式只能用在短变量声明，用在var会报错。

  还有一种很奇怪的赋值方法，用常量赋值：
  symbol := [...]string{USD:"i",RMB:"k"}
  有点类似于map。其中USD和RMB是被定义为int类型常量（当然也可以自己定义类型）然后这里的索引是随机的，i的索引可能是0也可能是1。感觉意义不明。
  这种形式也有：
  r := [...]int{99:-1}
  这种是声明了100个元素，第100个是-1，其他都是0。

  不管是var还是短变量声明。赋值的时候都要有=[]int{ }表示为数组赋值。
  另外也可以重新赋值：
  a = [3]int{1,2,3} 这样赋值可以直接整个数组从头到尾重新赋值。没写的用零值补上。
  当然也可以用索引访问单个元素来重新赋值： a[0] = 4

3.函数中的数组传递
  函数可以直接返回数组。但是接收时，除非用make(是完全错误的！因为数组不能用make！！！！！！！！！make是用在slice,map,chan等类型）要用指针传递。传入时就传&array。测试发现数组名就是个名字，数组名并不是一个指针。而且传入参数有严格归定数组就是数组，传入&array[0]是错的。在c里面，传入数组是通过指针来实现的。传入的是数组名。数组名就是一个指针。指向第一个元素地址。而这里并不是。
  这里传入数组的指针之后，可以以下标形式访问，也可以用*符号访问，用下标是对单个元素访问，用*则是对全部，一般用来对整个数组修改如归零操作： *ptr = []int{} 重新赋值直接归零。

4.切片(slice):
  slice像一个没有长度的数组，长度可以变化。可以用make分配内存，这样传入函数时就不用传指针了。（也是错的。并不是因为make起作用，而是因为slice本身就有指针，传进去的就是指针）然后它可以用来访问整个数组或者是部分数组。用slice = array[i:j]的形式。切片是数组的索引，或者是原来切片的索引，改变切片的元素，原数组或这原切片都会变。如果有一个切片先切了一个数组，然后又有一个切片切了这个切片，那么改变最后切的那个切片的元素，三者都会改变。
  slice有三个属性：指针、长度和容量。指针指向了数组，指向的元素是slice切出来的第一个元素（所以是引用）。长度是slice的长度（不会超过切片容量）。切片的容量是一般是slice第一个元素对应原数组中的位置一直到数组末尾一共占用的容量。len和cap函数可以求长度和容量。如果slice的引用超过了被引用对象的容量，那么就会宕机。如果引用的长度超出了被引用对象范围，那么就会扩大长度。（注意，这种情况只会出现在二次引用中，它的对象一定是切片。如果你切数组超出了长度就等于超出了容量）

  可以用两个for循环来查找两个slice的共同元素(数组也是可以的，两个不同长度的数组整体不能比较，但是数组的单个元素可以比较。）：(虽然效率不高)
  for _,s := range slice1 {
		for _,q := range slice2 {
				if s==q {
					fmt.Printf( )(或者搞个切片来存储)
				}
			}
		}

  另外字节slice和string的[:]的功能相似。但是字节slice返回的是一个[]byte slice，而string返回的是一个string。

###用来反转一个整型slice中的元素：（通过多重赋值而不是tmp第三者插入）
  for i,j :=0,len(s)-1 ; i<j ; i,j=i+1.j-1 {
		s[i],s[j]=s[j],s[i]
  }

5.数组和切片区别：
  数组和切片声明都是一样的格式，但是数组的[]里面是要有具体数值的，但是切片的[]是可以没有东西的。
  其次，slice不能直接比较（是slice整体）但是长度像等的array可以。（不然会报错）bytes包里面有Equal函数可以直接比较两个字节类型slice，但是对于其他类型的slice，只能自己写一个比较每个元素是否像等再返回true的函数来判断。slice唯一允许比较的是nil，而且slice也不能作为map中的键。
  如果要判断slice为空，应该是len（s）==0，而不是s==nil。因为就算slice!=nil，也可以为空。

6.make函数：
  用来创建一个具有指定元素类型、长度和容量的slice。其中容量参数可以省略，这种情况下，长度和容量像等。
  make([]T,len)  其实用make建立切片也建立了一个数组的副本，而这个切片，就是切这个副本数组的。
  make([]T,len,cap) 第三个参数cap可以省略。如果cap的值大于len，那么切片只切到了这个数组中的len的长度。剩下的为未来的数值留下存储空间。
###slice刚被声明出来时如果不赋值，那么它的容量是0，不能给它赋任何的值。除非用append为这个切片添加元素（类似于realloc）

7.append函数：
  append用来将元素追加到slice后面。
  s = append(s,r) 其中append第一个元素是切片本身，而r是要添加的元素。
  append也可以同时赋值多个值：
  s = append(s,r1,r2,r3,r4r,r5,r6)第一个参数还是为s本身
 
  append有两种处理模式，当这个切片容量够时，就定义一个新的slice，这个slice和原来的slice有相同的底层数组（就是在同一个数组里面切出来的）。然后将这个新元素赋值到指定位置，再返回这个slice，相当于是原slice的重赋值（底层函数相同可以这么做，不同时要借助copy）。如果容量不够时，就会建立一个新的底层数组，把原来切片元素赋值到底层数组，再用新切片来切。这个扩容是有一定倍数的，但是我们不知道原来slice和扩容后的slice是不是容量相同，所以要直接赋值。

8.copy函数：
  copy(dest slice,src slice) copy函数将源切片重第一个元素开始复制给目标切片。（第一个是目标，第二个是源）。一般情况下，目标切片都会比源切片要大。但是目标slice可能和源slice有相同底层数组，甚至可能出现元素重叠。copy会返回一个值，这个值是复制元素的个数。如果目标slice比源slice小也是可以的，那么就会重头开始复制，能放多少放多少。

###对于任何函数，只要有可能改变slice长度或者容量的，或者使slice指向不同的底层函数，都需要更新slice变量。虽然底层数组的元素是间接引用的，但是slice的指针、长度、容量不是。更新一个slice的指针、长度、容量，必须用显示赋值。
  slice并不是一个单纯的引用类型，而像一种聚合类型：
	type IntSlice struct {
		ptr *int
		len,cap int
	}

9.切片可以用来实现栈：
  stack = append(stack,v)//栈存放数据
  top := stack[len(stack)-1]//top访问顶层数据
  stack = stack[:len(stack)-1]//通过直接赋值来缩短stack删除数据

10.删除元素：
  要保留原来元素的顺序，那么就直接用copy：
  copy(slice[i:],slice[i+1:])//把后面的复制上来覆盖，但这样最后一个元素多了
  silce=slice[:len(slice)-1]//所以用整体赋值把最后一个删去。
  如果不需要保留顺序，那么就直接赋值就好了：
  slice[i] = slice[len(slice)-1]//直接把最后一个元素赋值过来
  slice = slice[:len(slice)-1]//把最后元素删掉
  
  go里面也可以实现双指针大法，原地修改数组，和c是一样的。删除重复元素屡试不爽，所以删除元素并没有限定以上两种。如果只是删除一个元素，上面可能更加快，但是要删除多个，比如重复元素，还是双指针来的好。
  删除元素还有第四种方法，用append来拼接这个元素两边的切片：
  nums = append(nums[:i],nums[i+1:]...) 这个...表示切片，省略报错。
  

  感觉copy作用更加精细，在slice内部运作，而直接赋值是面对整个slice来用的。

11.map:
  go里面有一个叫散列表的东西，而map就是用来引用散列表的。map的类型是map[v]t,所有的键都是都拥有相同数据类型，所有的值也拥有相同数据类型。但是键和值至之间的类型可以不一样。
  map的创建：
  一般用make来创建
  ages := make(map[string]int)
  ages["hello"]=31
  ages["world"]=30 make创建map之后可以直接用索引赋值初始化

  ages :=map[string]int{
			"hello":32,//赋值后面要有逗号
			"world":34,
	}
  也可以通过这种形式一步到位。这个叫做字面量定义，和上面的那个make形式不同，不要混淆。go里面字面量定义形式不在少数，还有数组，切片也可以这样做。
  新的空map表达形式: map[string]int{}
  但是如果不用make来创建，而直接声明： var m map[string]int 这种形式是nil型map，不能赋值给它。
###map的零值是nil

12.删除map的元素：
  delete(ages,"alice") 第一个参数是map的名，第二个参数是要删除的键。
###如果键在map中不存在，那么键对应的值就是值类型的零值。
###另外我们无法获取map的地址。
###我们可以用map["alice"]++等运算符给map中的值进行运算。就算alice不是键也可以，这样就等于新建了一个alice键，并且值为零值+1，就是1。
###命令行格式输入命令 gofmt -w .（w是写入的意思）会把当前目录的go文件全部格式化。

13.对map的值排序：
  map中键是无序的，如果要按照固定的顺序输出，那么就要给键排序。排序思路很简单，就是搞一个对应类型的切片，然后把键存进去，数组自己排序然后再用for遍历输出。其中int类型的键就是用泡沫排序实现。而字符串类型的键用sort包中的strings函数来排序（按照abcd...的顺序排序）。

14.在map中找键是否存在：
  一般用双重赋值形式：
  age,ok := ages["Bob"] 该表达式返回两个值，由age和ok来接收。前者是键对应的值，后者是一个布尔类型表示存不存在这个键。一般还会和if连用：
  if age,ok := ages["Bob"];ok{ }这样直接判断ok一步到位。

15.map的比较：
  map和slice一样，整体不能做比较。但是map可以和零值nil比较。
  如果想知道map是否一样，那就只能写函数，键一样，值一样，长度一样。
###用len函数可以求有多少个键。

16.结构体：
  结构体是将零个或者多个任意类型变量组合在一起的聚合数据类型。
  每个变量都叫做结构体的成员

  结构体的声明：
  type Employee struct {
		ID		int
		Name	string
		Address string
		Dob		time.Time
		Position string
  } 
  var dilbert Employee
  用type声明表示类型，用struct关键字表示这是一个结构体。这只是声明了一个类型，是自己建立的。这个类型就像是int，float一样。还要声明这个类型的变量。结构体的成员通过'.'来访问。dilbert.Name访问的是结构体中的name成员。所有成员都是变量，所以可以赋值：
dilbert.Name = "Jacksie"  当然也可以获取地址： *ptr = &dilbert.Name
  
  结构体的成员不能是它本身，但是却可以是它本身的指针：（结构体里面也可以有其他结构体）
  type tree struct {
		value  int
		left,right *tree
  }
  可以通过指针引用自身，实现二叉树（还可以实现链表和树）
###如果结构体成员的首字母大写，那么就是可导出的成员。

17.利用结构体字面量赋值：
  结构体固然可以单个访问变量赋值，但是实在太慢了。所以字面量赋值更佳。
  结构体字面量有两种形式。
  其一：
  p:= Point{1,2} 这种形式会依次定义类型的成员顺序进行赋值，没有赋值到的会自动取零值。但是这种方法要求记住成员，可读性不高，所以一般用第二种。
  其二：
  dilbert := Employee{:ID:2019214,Name:"Lily"} 形式就是都是一样的。变量名：=变量类型{ }。 没有提及的成员会是零值。赋值成员可以不按顺序来。

18.结构体指针：
  结构体指针是指向结构体的指针，其访问结构体成员和结构体变量名是一样的，也就是p.Name。当然也可以对某个成员取址：p=&dilbert.Name。可以通过*p来间接访问，可以赋值。 

19.结构体比较：
  结构体如果所有变量都是可以比较的，那么这个结构体就可以比较，可以用==或者!=来比较。会按照成员顺序依次比较。（这里的比较是指相同的结构体类型比较。不同结构体类型之间不能比较，就好像int和string之间不能比较是一样的。
  和别的任何可比较类型相似，结构体类型也可以作为map的键:
  type adress struct {
		hostname string
		port	 int
  }
  hits := make(map[address]int)
  hits[address{"golang.org",443}]++

20.go的结构体嵌套和匿名成员：
  结构体里面是可以嵌套其他结构体的，但是如果嵌套的多，引用就会写的很长。go里面有一个匿名成员的东西，可以省略中间的成员直接访问最底层成员：
  type Point struct {
		X,Y int
  }
  
  type Wheel Struct {   正常的是： type Wheel Struct {
		Point							p Point//这种就不是匿名成员，有个名字p
  		Radius int						Radius int
  }									}
  var w wheel
  w.x就可以直接访问point里面的x。像这种只嵌套类型名，不嵌套变量名的叫做匿名成员，可以跳过中间一堆成员直接访问最底层的成员。而类型名字大写则代表该成员可以导出。

  匿名成员的赋值：
  不能直接像之前字面量赋值，而是：
  w = Wheel{Point{8,8},65}赋值也要像这样嵌套式赋值。
  还有一种形式，像指定赋值的，更加清楚也更加复杂：
  w = Wheel{
		Point:Point{x:8,y:8},//不要忘记有逗号。还有如果成员是结构体，一定要写上类型
		Radius:65,//像上面这种Point{ }
  }	
###在go中，组合是面向对象编程方式的核心。  
