复合数据类型
1.数组：（一般很少用）
  声明时要规定数组长度，而且一定要是常数而不能是变量。（在编译的时候是具体的值，不能运行的时候输出进去）。而且不同长度的数组整体不能比较，但是单个数在元素可以比较。

2.数组的声明：
  var a [3]int 中括号里面一定要有东西，而且是编译时有具体数值。如果没有就是切片。
  初始化：
  var a [3]int=[3]int{1,2,3}
  也可以：
  a := [3]int{1,2,3}
  当然短变量声明时，赋值符号后面的那个中括号可以用三个.代表省略号代替，然后元素个数由后面赋值个数确定。注意这种形式只能用在短变量声明，用在var会报错。

  还有一种很奇怪的赋值方法，用常量赋值：
  symbol := [...]string{USD:"i",RMB:"k"}
  有点类似于map。其中USD和RMB是被定义为int类型常量（当然也可以自己定义类型）然后这里的索引是随机的，i的索引可能是0也可能是1。感觉意义不明。
  这种形式也有：
  r := [...]int{99:-1}
  这种是声明了100个元素，第100个是-1，其他都是0。

  不管是var还是短变量声明。赋值的时候都要有=[]int{ }表示为数组赋值。
  另外也可以重新赋值：
  a = [3]int{1,2,3} 这样赋值可以直接整个数组从头到尾重新赋值。没写的用零值补上。
  当然也可以用索引访问单个元素来重新赋值： a[0] = 4

3.函数中的数组传递
  函数可以直接返回数组。但是接收时，除非用make(是完全错误的！因为数组不能用make！！！！！！！！！make是用在slice,map,chan等类型）要用指针传递。传入时就传&array。测试发现数组名就是个名字，数组名并不是一个指针。而且传入参数有严格归定数组就是数组，传入&array[0]是错的。在c里面，传入数组是通过指针来实现的。传入的是数组名。数组名就是一个指针。指向第一个元素地址。而这里并不是。
  这里传入数组的指针之后，可以以下标形式访问，也可以用*符号访问，用下标是对单个元素访问，用*则是对全部，一般用来对整个数组修改如归零操作： *ptr = []int{} 重新赋值直接归零。

4.切片(slice):
  slice像一个没有长度的数组，长度可以变化。可以用make分配内存，这样传入函数时就不用传指针了。（也是错的。并不是因为make起作用，而是因为slice本身就有指针，传进去的就是指针）然后它可以用来访问整个数组或者是部分数组。用slice = array[i:j]的形式。切片是数组的索引，或者是原来切片的索引，改变切片的元素，原数组或这原切片都会变。如果有一个切片先切了一个数组，然后又有一个切片切了这个切片，那么改变最后切的那个切片的元素，三者都会改变。
  slice有三个属性：指针、长度和容量。指针指向了数组，指向的元素是slice切出来的第一个元素（所以是引用）。长度是slice的长度（不会超过切片容量）。切片的容量是一般是slice第一个元素对应原数组中的位置一直到数组末尾一共占用的容量。len和cap函数可以求长度和容量。如果slice的引用超过了被引用对象的容量，那么就会宕机。如果引用的长度超出了被引用对象范围，那么就会扩大长度。（注意，这种情况只会出现在二次引用中，它的对象一定是切片。如果你切数组超出了长度就等于超出了容量）

  可以用两个for循环来查找两个slice的共同元素(数组也是可以的，两个不同长度的数组整体不能比较，但是数组的单个元素可以比较。）：(虽然效率不高)
  for _,s := range slice1 {
		for _,q := range slice2 {
				if s==q {
					fmt.Printf( )(或者搞个切片来存储)
				}
			}
		}

  另外字节slice和string的[:]的功能相似。但是字节slice返回的是一个[]byte slice，而string返回的是一个string。

###用来反转一个整型slice中的元素：（通过多重赋值而不是tmp第三者插入）
  for i,j :=0,len(s)-1 ; i<j ; i,j=i+1.j-1 {
		s[i],s[j]=s[j],s[i]
  }

5.数组和切片区别：
  数组和切片声明都是一样的格式，但是数组的[]里面是要有具体数值的，但是切片的[]是可以没有东西的。
  其次，slice不能直接比较（是slice整体）但是长度像等的array可以。（不然会报错）bytes包里面有Equal函数可以直接比较两个字节类型slice，但是对于其他类型的slice，只能自己写一个比较每个元素是否像等再返回true的函数来判断。slice唯一允许比较的是nil，而且slice也不能作为map中的键。
  如果要判断slice为空，应该是len（s）==0，而不是s==nil。因为就算slice!=nil，也可以为空。

6.make函数：
  用来创建一个具有指定元素类型、长度和容量的slice。其中容量参数可以省略，这种情况下，长度和容量像等。
  make([]T,len)  其实用make建立切片也建立了一个数组的副本，而这个切片，就是切这个副本数组的。
  make([]T,len,cap) 第三个参数cap可以省略。如果cap的值大于len，那么切片只切到了这个数组中的len的长度。剩下的为未来的数值留下存储空间。
###slice刚被声明出来时如果不赋值，那么它的容量是0，不能给它赋任何的值。除非用append为这个切片添加元素（类似于realloc）

7.append函数：
  append用来将元素追加到slice后面。
  s = append(s,r) 其中append第一个元素是切片本身，而r是要添加的元素。
