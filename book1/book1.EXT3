一些疑惑：
1.命令行参数 原来命令行参数就是字面意思，在命令行里面输入参数
	编译的时候在指令后面加上任意字符，那个字符就是命令行里面的参数
		go run echo2.go 0000 //这个0000就是参数
  命令行参数主要用来接收参数，形成指令。假设写了一个程序，可以获取别的文件的所有数据并且处理。那么这个存续main函数就要接收这个文件。我们可以写成函数接收形参的样子，接收文件名字。那么这个时候命令汉参数就是这个文件的名字，main函数会接收命令行参数，并处理。
2.os包，Args变量 //os包是用来针对用户所用操作系统的相关操作
3.gofmt工具格式化文件 用go get golang.org/x/tools/cmd/goimports 来获取

1_2 命令行参数

1. ":=" 是短变量声明，【只能】用在【函数内部】。并且可以【同时】声明【多个】变量。
	a,b := 25,223(同时声明多个变量)

	声明一个空字符串有以下四种形式
	s := ""（隐式初始化）
	var s string
	var s =""
	var s string = ""（带var的是显示初始化）
  以上四种各有优劣。第一种是短声明，非常简洁。不能用在函数外部，不适合包级别的变量。第二种是依赖默认初始化字符串的值为“”。第三种几乎不会用，除非声明多个变量。第四种显得冗杂，但初始化不是零值时，是必须的。所以在实践中我们会用前两种（不是初始化零值的用第四种）用隐式初始化来声明不重要的。用显示初始化来声明重要的变量。

2. i++/i--是自增自减语句。它们是【语句】，而不像c那样是【表达式】。所以【j=i++是错的】，可以通过j=i+1来实现。另外语句【只有后缀形式】，【++i，--i】都是【违法】的。

3.for循环的实现 
#for格式之一：
		for initialization(初始化);condition(条件);post(执行后处理语句) {
			...
		}
  初始化语句在循环【开始前执行】，必须是一个【简单的语句】，比如一个【简短的变量声明】，一个【递增或赋值语句】、或者是一个【函数】的调用。条件语句是一个【布尔表达式】(bool)。在循环每一次迭代【开始前】推演。如果推演结果为【真】，循环【继续执行】。post语句在【循环体之后】被执行。然后【条件被再次推演】，如果条件【为真】则【继续执行】。条件【变假】后【退出循环】。
  另外三个语句【都可以省略】，但分号不能省略。如果三个同时省略，分号也可以省略，变成for{ ... }的一个无限循环。如果【只有条件语句】，那么【分号】也可以【省略】，这就是go里面【while循环的实现】。for condition {...}

###循环流程：循环开始预处理（初始化）->循环条件判断（迭代开始）->循环体->post语句->循环条件判断（新的迭代开始）->循环体->post语句->循环条件判断（新的迭代开始）->循环体->post语句->...->循环条件判断（新的迭代开始）（如果）为假。->退出循环

#for格式之二：
		for condition {
			...
		}
  go语言中while的实现

#for格式之三：
		for {
			...
		}
  无限循环的实现，可以用break，return退出循环
!!!###for 1 {...}不可以！！！这里特别注意！for的条件判断在c里面是用int类型判断，1执行，0退出。但是go里面规定是一个布尔表达式，是【表达式】！！！一定要有判断，返回true/false。注意true和false不是一个【布尔表达式（要有运算符）】，是布尔类型。
###语句和表达式的关系：表达式是一段可以求值的代码（像布尔表达式的值返回true或者false）而语句只是一段可以执行的代码，但语句不一定能求值。所以语句的概念比表达式要大一点。
  
#for格式之三：（用range遍历）
	for v,ok := range (array,slice or others) {//这里的v和ok是变量用来存储range返回值
				...
	}
  每一次迭代，range产生一对值：索引和这个索引处元素的值。如果不需要索引，就要处理掉这个返回的索引。我们可以把它赋值给空标识符（_)来丢弃它。空标识符可以用在任何语法需要变量名但是程序逻辑不需要的地方。（range返回需要变量接收，但是程序逻辑不需要这个变量）
	for _,ok := range (array,slice or others) {
				...
	}
  索引可以不要，同时值也可以丢弃，只要索引。这个时候只写一个变量接收range的返回值就可以实现了。
	for v := range (array,slice or others) {
				...
	}

###go不允许出现任何无用的变量

4.strings包中Join函数的运用
  join函数用于拼接字符串切片。是把字符串切片拼成一个字符串。
    slice = []string{"12","23","34"}
	str := string.Join(slice,"--")
	结果就是str = "12--23--34"
  如果逗号后面是空字符串，那么可以实现最直接的字符串连接。go的具有字符串类型，专门用来存储字符串。而c语言里面的字符串是通过字符数组实现的。字符串数组要通过二维数组实现。而如果要改变字符串里面的单个变量，原来的思路就不可取了。go语言的字符串（字符串类型）无法直接修改每一个字符的元素，只能通过重新构造新的字符串并赋值给原来的字符串变量实现。

###当格式化输出的时候，如果输出的占位字符和数据类型不一样，那么还是会隐式转化，正常输出，但是会有错误提醒： %!d(string=1)这里是占位字符是整型，提示应该是string。
